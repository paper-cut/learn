# 更灵活定位内存地址

## and和or指令

and：与运算 只有1和1结果为1，其余都为0

例：and al,00001111B
按位将al中的数据和00001111进行与运算

or：或运算 只有0和0结果为0，其余都为1

例：or al,00001111B

两个指令的功能

and：可以将al中的某一位设为0 and al,10111111B

or:可以将al中的某一位设为1 or al,01000000B

## ASCLL码

将机器码和我们人类能够理解的单词或语言进行得约定俗成的编码方案，这玩意支持英文和字符，但是不支持中文。

unicode编码集中的UTF8倒是支持中文，同时兼容ascll

## 以字符形式给出的数据

在汇编程序中，以'......'代表字符串，例如db 'unIX' 就相当于了 db 75H,6EH,49H,58H

## 大小写转换的问题

大写字母和小写字母的二进制差别是小写字母的二进制编码的第五位是1，大写字母是0，只有第五位不同（在ASCLL码中）

详见9.asm

## [bx+idata]

用bx加一个常数做偏离地址

[bx+idata]表示一个内存单元，他的偏移地址为(bx)+idata

例 mov ax,[bx+200]
是将ds:bx+200这一内存单元中的数据送入ax寄存器中

也可以写成如下格式

mov ax,[200+bx];mov ax,200[bx];mov ax,[bx].200

## 用[bx+idata]的方式进行数组的处理

同样是转换大小写，详见10.asm

[bx+idata]的形式为高级语言实现数组提供了很好的基础

## SI和DI

si和di寄存器实现地和bx类似的功能，提供一个数据的偏移地址。

只不过si和di不能拆开（拆成两个八位寄存器）使用

在复制数据的时候，我们一般使用ds:si来指向原始数据，用ds:di指向要复制的区域

## [bx+bi]和[bx+di]

两个变量相加的方式指明一个内存单元

## [bx+si+idata]和[bx+di+idata]

果然是很灵活表示内存地址的方法

## 不同的寻址方式的灵活应用

寻址方法：即定位内存的方法

[idata]是一个常量表示地址；[bx]用一个变量表示内存地址；[bx+idata]也是表示一个内存地址；[bx+si];[bx+si+idata]。

通过上面的方式，我们可以使用更加灵活的方式来定义一个内存地址。

见11.asm；12.asm

在多层循环中，cx的值需要进行保存，可以选择保存到其他寄存器中，但是寄存器的数量有限，可以选择将数据存入内存单元中。

一个比较好的做法，是将数据放入栈中
需要暂存数据的时候，堆栈是个很不错的选择

详见13.asm

## 小结

本章主要学习了更加灵活的寻找内存地址的方式



