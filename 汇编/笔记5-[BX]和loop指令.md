# [BX]和loop指令

## [bx]

和在debug中使用mov ax,[0]是将ds:0000H这一内存单元中的数据存入ax寄存器不同，在编译器中会把该句理解为将0000H这一数据存如ax寄存器中。

如果想要实现将内存单元中的数据存入ax，可以先将偏移地址存入寄存器bx 

<code>
mov dx,0000H
mov ax,[bx]
</code>

这样就可以实现将ds:0000H这一内存单元中的数据存入ax寄存器。

也可以使用

mov ax,ds:[0]这样的方式将内存单元中的内容放入寄存器

### inc指令 
inc bx 即bx寄存器中的数据自加一

## loop指令

loop:循环

格式：loop 标号

实例：实现运算2^12

cx寄存器中存入循环执行的次数，每次loop语句执行后，cx会自动减一，cx中的值为0时会向下执行

标号是标式循环的起始位置，loop是循环的结束位置，执行的程序段要写到标号和loop之间。

实例：

<code>

assume cs:code

code segment

    mov ax,2
    mov cs,11
    s:add ax,ax
    loop s
    mov ax,4c00h
    int 21h
code ends

end

</code>

## 在Debug中调试loop指令形成的循环时

如果循环的次数过多，使用t命令来跟踪会很累

所以我们引入了G命令（跳转至某行）来解决

或者P命令

G 偏移地址 ：直接跳转到偏移地址的指令位置，中间的循环全部运行完毕

P 直接执行完循环

## loop和[dx]的联合应用

可以通过改变dx的值，循环访问内存单元中的数据

## 段前缀

例如 mov ax,ds:[0] 其中的ds就是段前缀，如果写作 mov ax,[bx]得话，段前缀默认为ds。其他情况也可以指定段前缀为cs、bx等

## 一段安全的空间

没有触碰到系统、或者其他程序所占用的内存单元的空间

在DOS方式下，一般情况 0:200-0:2FF的256个字节的空间是安全的

## 段前缀的使用

es：额外的段寄存器，当段寄存器不够用的时候，可以带上它

代码的优化

## 小结

