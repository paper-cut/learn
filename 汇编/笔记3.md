# 寄存器（内存访问）

## 内存中字的存储

内存中一个字的高位和低位数据会分开存储在两个不同的内存单元中，高地址对应高位，低地址对应低位。

任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成是两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元

## DS和[address]

当CPU要读取内存单元中的数据的时候，需要获得内存单元的地址

在8086CPU中，DS寄存器负责存储内存单元的段地址

[address]以这样的方式来代表偏移地址

比如我们把内存单元 10000H中的数据存储到ax寄存器中

mov bx,1000H
mov ds,bx
mov ax,[0]

由于CPU不能使用mov指令直接赋予段寄存器数据，只能通过一个通用寄存器来为中介赋予段寄存器ds值

我们要把寄存器中的数据存储到内存单元中也类似

mov bx,1000H
mov ds,bx
mov [0],ax

就把ax中的内容存储到10000H这个地址中了

## 字的传送

由于8086CPU是16位的结构，一次可以传输16位的数据，也就是一次传输一个字

通过mov、add、sub等语句，实现字在寄存器和内存之间的转移

同时根据对应的寄存器的不同来确定所转移的是字（ax），还是字节(ah or al)

## mov add sub指令

指令的几种使用形式

<ul>
<li>mov 寄存器 ， 数据
<li>mov 寄存器 ， 寄存器
<li>mov 寄存器 ， 内存单元
<li>mov 内存单元 ， 寄存器
<li>mov 段寄存器 ， 寄存器
<li>mov 寄存器 ，段寄存器
</ul>

add和sub指令则和mov相同基本

## 数据段

对于8086PC机来说我们可以根据需要将一组内存单元定义为一个段（可以是代码段，也可以是数据段）

访问一个数据段的内容的时候，可以将ds寄存器赋值为该数据段的段地址，然后再通过改变偏移地址来获取各个内存单元

## 栈

栈是一个具有特殊数据访问方式的空间

这个空间中的数据，最先进入的数据最后出来，最后进去的最先出来。相当于一个书箱，最先放入的书只能最后拿出来。

## CPU提供的栈机制

CPU可以将一段内存当作栈来使用

8086CPU中以SS寄存器存放栈顶的段地址，以SP寄存器存放栈顶的偏移地址。SS:SP指向栈的栈顶元素

入栈和出栈命令 ：

push 入栈： push ax 即将ax寄存器中的数据入栈

pop  出栈： pop ax 即将栈顶一个字存入到ax寄存器中

push和pop指令都是以字为单位

栈中的高位地址储存字的高位数据

数据入栈或出栈后，SS:SP会发生改变（入栈：减；出栈：加）

初始状态下的栈（没有数据）的SS:SP为栈空间最高地址单元的下一个单元

### 注意一点

SS:SP改变后，原本存储在内存单元中的数据并不会丢失，只是会在新的数据push进来时被重新写入。
所以这是一个找回丢失数据的原理

格式化硬盘，只是改变了索引的标签，一般不会直接删除数据

## 栈顶越界的问题

SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶

当栈满的时候使用入栈指令或者在栈空的时候使用出栈指令会导致栈的溢出，会覆盖到栈外面的数据或者获取栈外面的数据

栈顶越界十分危险

我们希望CPU有记录栈顶上下限的寄存器，但是8086CPU并没有。8086CPU并不知道栈的空间有多大，他只知道栈顶在哪

我们在编程时需要注意一下栈空间的大小，操心栈顶越界的问题

## push pop指令

push和pop指令可以在寄存器和栈之间进行数据传输

以push为例：
1.push 寄存器；
2.push 段寄存器；
3.push 内存单元（偏离地址）；

以上是将寄存器和内存单元中的数据入栈

## 栈段

类似数据段和代码段

是在段地址确定的前提下，以偏移地址的大小确定的连续的内存地址

